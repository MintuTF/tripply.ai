import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { createEvents, EventAttributes } from 'ics';
import { Card, Trip } from '@/types';

/**
 * Export trip itinerary to PDF
 */
export function exportToPDF(trip: Trip, cards: Card[]) {
  const doc = new jsPDF();

  // Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(trip.title, 20, 20);

  // Trip Details
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(`${trip.dates.start} to ${trip.dates.end}`, 20, 30);

  const party = trip.party_json;
  const partyText = `${party.adults} adult${party.adults !== 1 ? 's' : ''}${party.children ? `, ${party.children} child${party.children !== 1 ? 'ren' : ''}` : ''}`;
  doc.text(partyText, 20, 37);

  if (trip.budget_range && trip.budget_range.length === 2) {
    doc.text(`Budget: $${trip.budget_range[0]} - $${trip.budget_range[1]}`, 20, 44);
  }

  // Group cards by day
  const scheduledCards = cards.filter(c => c.day).sort((a, b) => {
    if (a.day !== b.day) return (a.day || 0) - (b.day || 0);
    return (a.order || 0) - (b.order || 0);
  });

  const cardsByDay = scheduledCards.reduce((acc, card) => {
    const day = card.day!;
    if (!acc[day]) acc[day] = [];
    acc[day].push(card);
    return acc;
  }, {} as Record<number, Card[]>);

  let yPos = 55;

  // Day-by-day itinerary
  Object.entries(cardsByDay).forEach(([day, dayCards]) => {
    // Check if we need a new page
    if (yPos > 250) {
      doc.addPage();
      yPos = 20;
    }

    // Day header
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text(`Day ${day}`, 20, yPos);
    yPos += 10;

    // Day activities table
    const tableData = dayCards.map((card) => {
      const payload = typeof card.payload_json === 'string'
        ? JSON.parse(card.payload_json)
        : card.payload_json;

      return [
        card.time_slot || '',
        payload.name || '',
        card.type.charAt(0).toUpperCase() + card.type.slice(1),
        payload.address || '',
      ];
    });

    autoTable(doc, {
      startY: yPos,
      head: [['Time', 'Name', 'Type', 'Location']],
      body: tableData,
      theme: 'grid',
      styles: { fontSize: 10 },
      headStyles: { fillColor: [88, 166, 193] },
      margin: { left: 20, right: 20 },
    });

    yPos = (doc as any).lastAutoTable.finalY + 10;
  });

  // Unscheduled items
  const unscheduled = cards.filter(c => !c.day);
  if (unscheduled.length > 0) {
    if (yPos > 250) {
      doc.addPage();
      yPos = 20;
    }

    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text('Unscheduled Items', 20, yPos);
    yPos += 10;

    const unscheduledData = unscheduled.map((card) => {
      const payload = typeof card.payload_json === 'string'
        ? JSON.parse(card.payload_json)
        : card.payload_json;

      return [
        payload.name || '',
        card.type.charAt(0).toUpperCase() + card.type.slice(1),
        payload.address || '',
      ];
    });

    autoTable(doc, {
      startY: yPos,
      head: [['Name', 'Type', 'Location']],
      body: unscheduledData,
      theme: 'grid',
      styles: { fontSize: 10 },
      headStyles: { fillColor: [139, 92, 246] },
      margin: { left: 20, right: 20 },
    });
  }

  // Footer
  const pageCount = (doc as any).internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(10);
    doc.setFont('helvetica', 'italic');
    doc.text(
      `Generated by Tripply - Page ${i} of ${pageCount}`,
      doc.internal.pageSize.width / 2,
      doc.internal.pageSize.height - 10,
      { align: 'center' }
    );
  }

  // Save
  doc.save(`${trip.title.replace(/\s+/g, '_')}_Itinerary.pdf`);
}

/**
 * Export trip to calendar (.ics file)
 */
export async function exportToCalendar(trip: Trip, cards: Card[]) {
  const scheduledCards = cards.filter(c => c.day && c.time_slot);

  const startDate = new Date(trip.dates.start);

  const events: EventAttributes[] = scheduledCards.map((card) => {
    const payload = typeof card.payload_json === 'string'
      ? JSON.parse(card.payload_json)
      : card.payload_json;

    // Calculate event date
    const eventDate = new Date(startDate);
    eventDate.setDate(startDate.getDate() + (card.day! - 1));

    // Parse time slot (HH:MM format)
    const [hours, minutes] = (card.time_slot || '09:00').split(':').map(Number);
    eventDate.setHours(hours, minutes, 0);

    // Event duration (default 1 hour)
    const duration = card.type === 'activity'
      ? { hours: 2 }
      : card.type === 'food'
      ? { hours: 1, minutes: 30 }
      : { hours: 1 };

    return {
      start: [eventDate.getFullYear(), eventDate.getMonth() + 1, eventDate.getDate(), hours, minutes],
      duration,
      title: `${payload.name} - ${trip.title}`,
      description: payload.description || `${card.type} for ${trip.title}`,
      location: payload.address || '',
      status: 'CONFIRMED' as const,
      busyStatus: 'BUSY' as const,
    };
  });

  const { error, value } = createEvents(events);

  if (error) {
    console.error('Calendar export error:', error);
    throw new Error('Failed to create calendar events');
  }

  // Download .ics file
  const blob = new Blob([value!], { type: 'text/calendar' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${trip.title.replace(/\s+/g, '_')}_Calendar.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Generate shareable link for trip
 */
export function generateShareLink(tripId: string): string {
  const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';
  return `${baseUrl}/trips/${tripId}?shared=true`;
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy:', error);
    return false;
  }
}
